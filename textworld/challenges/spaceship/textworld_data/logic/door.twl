# door
type d : t {
    predicates {
        open(d);
        closed(d);
        locked(d);

        link(r, d, r);
    }

    rules {
        lock/d    :: $at(P, r) & $link(r, d, r') & $link(r', d, r) & $in(k, I) & $match(k, d) & closed(d) -> locked(d);
        unlock/d  :: $at(P, r) & $link(r, d, r') & $link(r', d, r) & $in(k, I) & $match(k, d) & locked(d) -> closed(d);

        open/d    :: $at(P, r) & $link(r, d, r') & $link(r', d, r) & closed(d) -> open(d) & free(r, r') & free(r', r);
        close/d   :: $at(P, r) & $link(r, d, r') & $link(r', d, r) & open(d) & free(r, r') & free(r', r) -> closed(d);
        
        #lock/close/d/b  :: $at(P, r) & $at(s, r) & $on(c, s) & $open(c) & $in(b, c) & $pair(b, d) & pushed(b) & open(d) -> unpushed(b) & locked(d);
        #unlock/open/d/b :: $at(P, r) & $at(s, r) & $on(c, s) & $open(c) & $in(b, c) & $pair(b, d) & unpushed(b) & locked(d) -> pushed(b) & open(d);




        lock/close/d/b  :: $at(P, r) & $at(s, r) & $on(c, s) & $open(c) & $in(b, c) & $pair(b, d) & $link(r, d, r') & $link(r', d, r) & pushed(b) & closed(d) -> unpushed(b) & locked(d);
        unlock/open/d/b :: $at(P, r) & $at(s, r) & $on(c, s) & $open(c) & $in(b, c) & $pair(b, d) & $link(r, d, r') & $link(r', d, r) & unpushed(b) & locked(d) -> pushed(b) & closed(d);





        #lock/close/d/b  :: $at(P, r) & $at(s, r) & $on(c, s) & $open(c) & $in(b, c) & $link(r', d, r'') & $link(r'', d, r') & $pair(b, d) & pushed(b) & open(d) & free(r', r'') & free(r'', r') -> unpushed(b) & locked(d);
        #unlock/open/d/b :: $at(P, r) & $at(s, r) & $on(c, s) & $open(c) & $in(b, c) & $link(r', d, r'') & $link(r'', d, r') & $pair(b, d) & unpushed(b) & locked(d) -> pushed(b) & open(d) & free(r', r'') & free(r'', r');

        #lock/close/d/b  :: $at(P, r) & $at(s, r) & $on(c, s) & $open(c) & $in(b, c) & $link(r, d, r') & $link(r', d, r) & $pair(b, d) & pushed(b) & open(d) & free(r, r') & free(r', r) -> unpushed(b) & locked(d);
        #unlock/open/d/b :: $at(P, r) & $at(s, r) & $on(c, s) & $open(c) & $in(b, c) & $link(r, d, r') & $link(r', d, r) & $pair(b, d) & unpushed(b) & locked(d) -> pushed(b) & open(d) & free(r, r') & free(r', r);

        #lock/close/d/b  :: $at(P, r) & $at(s, r) & $on(c, s) & $open(c) & $in(b, c) & $link(r, d, r') & $link(r', d, r) & $pair(b, d) & pushed(b) & closed(d) -> unpushed(b) & locked(d);
        #unlock/open/d/b :: $at(P, r) & $at(s, r) & $on(c, s) & $open(c) & $in(b, c) & $link(r, d, r') & $link(r', d, r) & $pair(b, d) & unpushed(b) & locked(d) -> pushed(b) & closed(d);

        #open/dr    :: $at(P, r) & $link(r, d, r') & $link(r', d, r) & closed(d) -> open(d) & free(r, r') & free(r', r);  
        #close/dr   :: $at(P, r) & $link(r, d, r') & $link(r', d, r) & open(d) & free(r, r') & free(r', r) -> closed(d);

        examine/d :: at(P, r) & $link(r, d, r') -> at(P, r);  # Nothing changes.
    }

    reverse_rules {
        lock/d :: unlock/d;
        open/d :: close/d;
        lock/close/d/b :: unlock/open/d/b;
        #open/dr :: close/dr;

    }

    constraints {
        d1 :: open(d)   & closed(d) -> fail();
        d2 :: open(d)   & locked(d) -> fail();
        d3 :: closed(d) & locked(d) -> fail();

        # A door can't be used to link more than two rooms.
        link1 :: link(r, d, r') & link(r, d, r'') -> fail();
        link2 :: link(r, d, r') & link(r'', d, r''') -> fail();

        # There's already a door linking two rooms.
        link3 :: link(r, d, r') & link(r, d', r') -> fail();

        # There cannot be more than four doors in a room.
        too_many_doors :: link(r, d1: d, r1: r) & link(r, d2: d, r2: r) & link(r, d3: d, r3: r) & link(r, d4: d, r4: r) & link(r, d5: d, r5: r) -> fail();

        # There cannot be more than four doors in a room.
        dr1 :: free(r, r1: r) & link(r, d2: d, r2: r) & link(r, d3: d, r3: r) & link(r, d4: d, r4: r) & link(r, d5: d, r5: r) -> fail();
        dr2 :: free(r, r1: r) & free(r, r2: r) & link(r, d3: d, r3: r) & link(r, d4: d, r4: r) & link(r, d5: d, r5: r) -> fail();
        dr3 :: free(r, r1: r) & free(r, r2: r) & free(r, r3: r) & link(r, d4: d, r4: r) & link(r, d5: d, r5: r) -> fail();
        dr4 :: free(r, r1: r) & free(r, r2: r) & free(r, r3: r) & free(r, r4: r) & link(r, d5: d, r5: r) -> fail();

        free1 :: link(r, d, r') & free(r, r') & closed(d) -> fail();
        free2 :: link(r, d, r') & free(r, r') & locked(d) -> fail();
    }

    inform7 {
        type {
            kind :: "door";
            definition :: "door is openable and lockable.";
        }

        predicates {
            open(d)   :: "The {d} is open";
            closed(d) :: "The {d} is closed";
            locked(d) :: "The {d} is locked";
            
            link(r, d, r') :: "";  # No equivalent in Inform7.
        }

        commands {
            open/d    :: "open {d}" :: "opening {d}";
            close/d   :: "close {d}" :: "closing {d}";

            unlock/d  :: "unlock {d} with {k}" :: "unlocking {d} with the {k}";
            lock/d    :: "lock {d} with {k}" :: "locking {d} with the {k}";

            lock/close/d/b  :: "unpush {b}" :: "unpushing the {b}";
            unlock/open/d/b :: "push {b}" :: "pushing the {b}";

            #open/dr    :: "open {d}" :: "opening {d}";
            #close/dr   :: "close {d}" :: "closing {d}";

            examine/d :: "examine {d}" :: "examining the {d}";
        }
    }
}

{"version": 1, "world": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_0", "type": "r"}]}, {"name": "at", "arguments": [{"name": "s_0", "type": "s"}, {"name": "r_0", "type": "r"}]}, {"name": "closed", "arguments": [{"name": "c_0", "type": "c"}]}, {"name": "closed", "arguments": [{"name": "c_1", "type": "c"}]}, {"name": "closed", "arguments": [{"name": "c_2", "type": "c"}]}, {"name": "closed", "arguments": [{"name": "c_3", "type": "c"}]}, {"name": "on", "arguments": [{"name": "c_0", "type": "c"}, {"name": "s_0", "type": "s"}]}, {"name": "on", "arguments": [{"name": "c_1", "type": "c"}, {"name": "s_0", "type": "s"}]}, {"name": "on", "arguments": [{"name": "c_2", "type": "c"}, {"name": "s_0", "type": "s"}]}, {"name": "on", "arguments": [{"name": "c_3", "type": "c"}, {"name": "s_0", "type": "s"}]}, {"name": "on", "arguments": [{"name": "cpu_0", "type": "cpu"}, {"name": "s_0", "type": "s"}]}, {"name": "unread/e", "arguments": [{"name": "cpu_0", "type": "cpu"}]}], "grammar": {"theme": "spaceship", "names_to_exclude": [], "include_adj": false, "blend_descriptions": false, "ambiguous_instructions": false, "only_last_action": false, "blend_instructions": false, "allowed_variables_numbering": false, "unique_expansion": false}, "quests": [{"desc": "", "reward": 1, "commands": [], "win_events": [{"commands": [], "actions": [], "condition": {"name": "trigger", "preconditions": [{"name": "open", "arguments": [{"name": "c_2", "type": "c"}]}], "postconditions": [{"name": "open", "arguments": [{"name": "c_2", "type": "c"}]}, {"name": "event", "arguments": [{"name": "c_2", "type": "c"}]}]}}], "fail_events": []}, {"desc": "", "reward": 1, "commands": [], "win_events": [{"commands": [], "actions": [], "condition": {"name": "trigger", "preconditions": [{"name": "open", "arguments": [{"name": "c_1", "type": "c"}]}, {"name": "event", "arguments": [{"name": "c_2", "type": "c"}]}], "postconditions": [{"name": "open", "arguments": [{"name": "c_1", "type": "c"}]}, {"name": "event", "arguments": [{"name": "c_2", "type": "c"}]}, {"name": "event", "arguments": [{"name": "c_1", "type": "c"}, {"name": "c_2", "type": "c"}]}]}}], "fail_events": []}], "infos": [["P", {"id": "P", "type": "P", "name": null, "noun": null, "adj": null, "desc": null, "room_type": "cook", "definite": null, "indefinite": null, "synonyms": null}], ["I", {"id": "I", "type": "I", "name": null, "noun": null, "adj": null, "desc": null, "room_type": null, "definite": null, "indefinite": null, "synonyms": null}], ["r_0", {"id": "r_0", "type": "r", "name": "Test Room", "noun": null, "adj": null, "desc": "This is a room which includes a table, a laptop and 4.00 boxes. Each box has a color on it which is distinguished by. Using the laptop, the agent can check the message in which says which box should be open to give the agent the maximum score. The message is the best clue to win. ", "room_type": "cook", "definite": null, "indefinite": null, "synonyms": null}], ["s_0", {"id": "s_0", "type": "s", "name": "Table", "noun": null, "adj": null, "desc": "This is a regular table.", "room_type": "cook", "definite": null, "indefinite": null, "synonyms": null}], ["c_0", {"id": "c_0", "type": "c", "name": "Red box", "noun": null, "adj": null, "desc": "This a Red box.", "room_type": "cook", "definite": null, "indefinite": null, "synonyms": null}], ["c_1", {"id": "c_1", "type": "c", "name": "Black box", "noun": null, "adj": null, "desc": "This a Black box.", "room_type": "cook", "definite": null, "indefinite": null, "synonyms": null}], ["c_2", {"id": "c_2", "type": "c", "name": "White box", "noun": null, "adj": null, "desc": "This a White box.", "room_type": "cook", "definite": null, "indefinite": null, "synonyms": null}], ["c_3", {"id": "c_3", "type": "c", "name": "Green box", "noun": null, "adj": null, "desc": "This a Green box.", "room_type": "cook", "definite": null, "indefinite": null, "synonyms": null}], ["cpu_0", {"id": "cpu_0", "type": "cpu", "name": "laptop", "noun": null, "adj": null, "desc": "This is a laptop which is on the table. You can do regular things with this, like check your emails, watch YouTube, Skype with family, etc. Check your emails to find out which box is important.", "room_type": "cook", "definite": null, "indefinite": null, "synonyms": null}]], "KB": {"logic": "# room\ntype r {\n    predicates {\n        at(P, r);\n        at(t, r);\n\n        north_of(r, r);\n        west_of(r, r);\n\n        north_of/d(r, d, r);\n        west_of/d(r, d, r);\n\n        free(r, r);\n\n        south_of(r, r') = north_of(r', r);\n        east_of(r, r') = west_of(r', r);\n\n        south_of/d(r, d, r') = north_of/d(r', d, r);\n        east_of/d(r, d, r') = west_of/d(r', d, r);\n    }\n\n    rules {\n        go/north :: at(P, r) & $north_of(r', r) & $free(r, r') & $free(r', r) -> at(P, r');\n        go/south :: at(P, r) & $south_of(r', r) & $free(r, r') & $free(r', r) -> at(P, r');\n        go/east  :: at(P, r) & $east_of(r', r) & $free(r, r') & $free(r', r) -> at(P, r');\n        go/west  :: at(P, r) & $west_of(r', r) & $free(r, r') & $free(r', r) -> at(P, r');\n    }\n\n    reverse_rules {\n        go/north :: go/south;\n        go/west :: go/east;\n    }\n\n    constraints {\n        r1 :: at(P, r) & at(P, r') -> fail();\n        r2 :: at(s, r) & at(s, r') -> fail();\n        r3 :: at(c, r) & at(c, r') -> fail();\n\n        # An exit direction can only lead to one room.\n        nav_rr1 :: north_of(r, r') & north_of(r'', r') -> fail();\n        nav_rr2 :: south_of(r, r') & south_of(r'', r') -> fail();\n        nav_rr3 :: east_of(r, r') & east_of(r'', r') -> fail();\n        nav_rr4 :: west_of(r, r') & west_of(r'', r') -> fail();\n\n        # Two rooms can only be connected once with each other.\n        nav_rrA :: north_of(r, r') & south_of(r, r') -> fail();\n        nav_rrB :: north_of(r, r') & west_of(r, r') -> fail();\n        nav_rrC :: north_of(r, r') & east_of(r, r') -> fail();\n        nav_rrD :: south_of(r, r') & west_of(r, r') -> fail();\n        nav_rrE :: south_of(r, r') & east_of(r, r') -> fail();\n        nav_rrF :: west_of(r, r')  & east_of(r, r') -> fail();\n    }\n\n    inform7 {\n        type {\n            kind :: \"room\";\n        }\n\n        predicates {\n            at(P, r) :: \"The player is in {r}\";\n            at(t, r) :: \"The {t} is in {r}\";\n            free(r, r') :: \"\";  # No equivalent in Inform7.\n\n            north_of(r, r') :: \"The {r} is mapped north of {r'}\";\n            south_of(r, r') :: \"The {r} is mapped south of {r'}\";\n            east_of(r, r') :: \"The {r} is mapped east of {r'}\";\n            west_of(r, r') :: \"The {r} is mapped west of {r'}\";\n\n            north_of/d(r, d, r') :: \"South of {r} and north of {r'} is a door called {d}\";\n            south_of/d(r, d, r') :: \"North of {r} and south of {r'} is a door called {d}\";\n            east_of/d(r, d, r') :: \"West of {r} and east of {r'} is a door called {d}\";\n            west_of/d(r, d, r') :: \"East of {r} and west of {r'} is a door called {d}\";\n        }\n\n        commands {\n            go/north :: \"go north\" :: \"going north\";\n            go/south :: \"go south\" :: \"going south\";\n            go/east :: \"go east\" :: \"going east\";\n            go/west :: \"go west\" :: \"going west\";\n        }\n    }\n}\n\n# CPU-Like\ntype cpu : o {\n    predicates {\n        read/e(cpu);\n        unread/e(cpu);\n    }\n\n    rules {\n        check/e1     :: $at(P, r) & $at(s, r) & $on(cpu, s) & unread/e(cpu) -> read/e(cpu);\n        check/e2     :: $at(P, r) & $in(cpu, I) & unread/e(cpu) -> read/e(cpu);\n    }\n\n    constraints {\n        cpu2 :: read/e(cpu) & unread/e(cpu) -> fail();        \n    }\n\n    inform7 {\n        type {\n            kind :: \"CPU-like\";\n            definition :: \"A CPU-like can be either read or unread. A CPU-like is usually unread.\";\n        }\n\n        predicates {\n            read/e(cpu)     :: \"The {cpu} is read\";\n            unread/e(cpu)   :: \"The {cpu} is unread\";\n        }\n\n        commands {            \n            check/e1     :: \"check laptop for email\"    :: \"checking email\";\n            check/e2     :: \"check laptop for email\"    :: \"checking email\";\n        }\n\n        code :: \"\"\"\n            Understand the command \"check\" as something new. \n            Understand \"check laptop for email\" as checking email. \n            checking email is an action applying to nothing. \n\n            Carry out checking email: \n                if a CPU-like (called pc) is unread: \n                    Say \"Open\u00a0the\u00a0white\u00a0box\u00a0to\u00a0win.\";\n                    Now the pc is read.\n\n            [Before checking email:\n                if a CPU-like (called pc) is read:\n                    Say \"You've already read all today's emails.\";\n                    rule fails;\n                otherwise:\n                    if a random chance of 3 in 4 succeeds:\n                        Say \"No emails yet! Wait.\";\n                        rule fails.\n\n            Carry out checking email: \n                if a CPU-like (called pc) is unread: \n                    Say \"Email: Your mission is started. You should go and check outside of the spaceship.\";\n                    Now the pc is read.]\n        \"\"\";\n    }\n}\n\n# door\ntype d : t {\n    predicates {\n        open(d);\n        closed(d);\n        locked(d);\n\n        link(r, d, r);\n    }\n\n    rules {\n        lock/d          :: $at(P, r) & $link(r, d, r') & $link(r', d, r) & $in(k, I) & $match(k, d) & closed(d) -> locked(d);\n        unlock/d        :: $at(P, r) & $link(r, d, r') & $link(r', d, r) & $in(k, I) & $match(k, d) & locked(d) -> closed(d);\n\n        open/d          :: $at(P, r) & $link(r, d, r') & $link(r', d, r) & closed(d) -> open(d) & free(r, r') & free(r', r);\n        close/d         :: $at(P, r) & $link(r, d, r') & $link(r', d, r) & open(d) & free(r, r') & free(r', r) -> closed(d);\n        \n        lock/close/db   :: $at(P, r) & $at(s, r) & $on(c, s) & $open(c) & $in(b, c) & $pair(b, d) & pushed(b) & open(d) & free(r, r') & free(r', r) -> unpushed(b) & locked(d);\n        unlock/open/db  :: $at(P, r) & $at(s, r) & $on(c, s) & $open(c) & $in(b, c) & $pair(b, d) & unpushed(b) & locked(d) -> pushed(b) & open(d) & free(r, r') & free(r', r);\n\n        lock/close/d/b  :: $at(P, r) & $at(s, r) & $on(c, s) & $open(c) & $in(b, c) & $pair(b, d) & $link(r', d, r'') & $link(r'', d, r') & pushed(b) & open(d) & free(r', r'') & free(r'', r') -> unpushed(b) & locked(d);\n        unlock/open/d/b :: $at(P, r) & $at(s, r) & $on(c, s) & $open(c) & $in(b, c) & $pair(b, d) & $link(r', d, r'') & $link(r'', d, r') & unpushed(b) & locked(d) -> pushed(b) & open(d) & free(r', r'') & free(r'', r');\n\n        examine/d       :: at(P, r) & $link(r, d, r') -> at(P, r);  # Nothing changes.\n    }\n\n    reverse_rules {\n        lock/d :: unlock/d;\n        open/d :: close/d;\n        lock/close/d/b :: unlock/open/d/b;\n        lock/close/db :: unlock/open/db;\n    }\n\n    constraints {\n        d1 :: open(d)   & closed(d) -> fail();\n        d2 :: open(d)   & locked(d) -> fail();\n        d3 :: closed(d) & locked(d) -> fail();\n\n        # A door can't be used to link more than two rooms.\n        link1          :: link(r, d, r') & link(r, d, r'') -> fail();\n        link2          :: link(r, d, r') & link(r'', d, r''') -> fail();\n\n        # There's already a door linking two rooms.\n        link3          :: link(r, d, r') & link(r, d', r') -> fail();\n\n        # There cannot be more than four doors in a room.\n        too_many_doors :: link(r, d1: d, r1: r) & link(r, d2: d, r2: r) & link(r, d3: d, r3: r) & link(r, d4: d, r4: r) & link(r, d5: d, r5: r) -> fail();\n\n        # There cannot be more than four doors in a room.\n        dr1   :: free(r, r1: r) & link(r, d2: d, r2: r) & link(r, d3: d, r3: r) & link(r, d4: d, r4: r) & link(r, d5: d, r5: r) -> fail();\n        dr2   :: free(r, r1: r) & free(r, r2: r) & link(r, d3: d, r3: r) & link(r, d4: d, r4: r) & link(r, d5: d, r5: r) -> fail();\n        dr3   :: free(r, r1: r) & free(r, r2: r) & free(r, r3: r) & link(r, d4: d, r4: r) & link(r, d5: d, r5: r) -> fail();\n        dr4   :: free(r, r1: r) & free(r, r2: r) & free(r, r3: r) & free(r, r4: r) & link(r, d5: d, r5: r) -> fail();\n\n        free1 :: link(r, d, r') & free(r, r') & closed(d) -> fail();\n        free2 :: link(r, d, r') & free(r, r') & locked(d) -> fail();\n    }\n\n    inform7 {\n        type {\n            kind       :: \"door\";\n            definition :: \"door is openable and lockable.\";\n        }\n\n        predicates {\n            open(d)         :: \"The {d} is open\";\n            closed(d)       :: \"The {d} is closed\";\n            locked(d)       :: \"The {d} is locked\";\n            \n            link(r, d, r')  :: \"\";  # No equivalent in Inform7.\n        }\n\n        commands {\n            open/d          :: \"open {d}\"            :: \"opening {d}\";\n            close/d         :: \"close {d}\"           :: \"closing {d}\";\n\n            unlock/d        :: \"unlock {d} with {k}\" :: \"unlocking {d} with the {k}\";\n            lock/d          :: \"lock {d} with {k}\"   :: \"locking {d} with the {k}\";\n\n            lock/close/d/b  :: \"push {b}\"            :: \"_pushing the {b}\";\n            unlock/open/d/b :: \"push {b}\"            :: \"_pushing the {b}\";\n\n            lock/close/db   :: \"push {b}\"            :: \"_pushing the {b}\";\n            unlock/open/db  :: \"push {b}\"            :: \"_pushing the {b}\";\n\n            examine/d       :: \"examine {d}\"         :: \"examining the {d}\";\n        }\n    }\n}\n\n# Inventory\ntype I {\n    predicates {\n        in(o, I);\n    }\n\n    rules {\n        inventory  :: at(P, r) -> at(P, r);  # Nothing changes.\n\n        take       :: $at(P, r) & at(o, r) -> in(o, I);\n        \n        take/c     :: $at(P, r) & $at(c, r) & $open(c) & in(o, c) -> in(o, I);\n        insert/c   :: $at(P, r) & $at(c, r) & $open(c) & in(o, I) -> in(o, c);\n\n        take/cs    :: $at(P, r) & $at(s, r) & $on(c, s) & $open(c) & in(o, c) -> in(o, I);\n        insert/cs  :: $at(P, r) & $at(s, r) & $on(c, s) & $open(c) & in(o, I) -> in(o, c);\n\n        take/s     :: $at(P, r) & $at(s, r) & on(o, s) -> in(o, I);\n        hook       :: $at(P, r) & $at(s, r) & in(o, I) -> on(o, s);\n\n        examine/I  :: in(o, I) -> in(o, I);  # Nothing changes.\n        examine/s  :: at(P, r) & $at(s, r) & $on(o, s) -> at(P, r);  # Nothing changes.\n        examine/c  :: at(P, r) & $at(c, r) & $open(c) & $in(o, c) -> at(P, r);  # Nothing changes.\n        examine/or :: at(P, r) & $in(o, r) -> at(P, r);  # Nothing changes.\n        examine/oc :: at(P, r) & $at(c, r) & $open(c) & $in(o, c) -> at(P, r);  # Nothing changes.\n        examine/os :: at(P, r) & $at(s, r) & $on(o, s) -> at(P, r);  # Nothing changes.\n    }\n\n    reverse_rules {    \n        inventory  :: inventory;\n\n        take/c     :: insert/c;\n        take/s     :: hook;\n        take/cs    :: insert/cs;\n\n        examine/I  :: examine/I;\n        examine/s  :: examine/s;\n        examine/c  :: examine/c;\n        examine/or :: examine/or;\n        examine/oc :: examine/oc;\n        examine/os :: examine/os;\n    }\n\n    inform7 {\n        predicates {\n            in(o, I) :: \"The player carries the {o}\";\n        }\n\n        commands {\n\n            inventory  :: \"inventory\" :: \"taking inventory\";\n\n            take       :: \"take {o}\" :: \"taking the {o}\";                \n\n            take/c     :: \"take {o} from {c}\" :: \"removing the {o} from the {c}\";\n            insert/c   :: \"insert {o} into {c}\" :: \"inserting the {o} into the {c}\";\n\n            take/cs    :: \"take {o} from {c}\" :: \"removing the {o} from the {c}\";\n            insert/cs  :: \"insert {o} into {c}\" :: \"inserting the {o} into the {c}\";\n\n            take/s     :: \"take {o} from {s}\" :: \"removing the {o} from the {s}\";\n            hook       :: \"hook {o} on {s}\" :: \"hooking the {o} on the {s}\";\n\n            examine/I  :: \"examine {o}\" :: \"examining the {o}\";\n            examine/s  :: \"examine {o}\" :: \"examining the {o}\";\n            examine/c  :: \"examine {o}\" :: \"examining the {o}\";\n            examine/or :: \"examine {o}\" :: \"examining the {o}\";\n            examine/oc :: \"examine {o}\" :: \"examining the {o}\";\n            examine/os :: \"examine {o}\" :: \"examining the {o}\";\n        }\n    }\n}\n\n# food\ntype f : o {\n    predicates {\n        edible(f);\n        eaten(f);\n    }\n\n    rules {\n        eat :: in(f, I) -> eaten(f);\n    }\n\n    constraints {\n        eaten1 :: eaten(f) & in(f, I) -> fail();\n        eaten2 :: eaten(f) & in(f, c) -> fail();\n        eaten3 :: eaten(f) & on(f, s) -> fail();\n        eaten4 :: eaten(f) & at(f, r) -> fail();\n    }\n\n    inform7 {\n        type {\n            kind :: \"food\";\n            definition :: \"food is edible.\";\n        }\n\n        predicates {\n            edible(f) :: \"The {f} is edible\";\n            eaten(f) :: \"The {f} is nowhere\";\n        }\n\n        commands {\n            eat :: \"eat {f}\" :: \"eating the {f}\";\n        }\n    }\n}\n\n# supporter\ntype s : t {\n    predicates {\n        on(o, s);\n        on(c, s);\n    }\n\n    inform7 {\n        type {\n            kind :: \"supporter\";\n            definition :: \"supporters are fixed in place.\";\n        }\n\n        predicates {\n            on(o, s) :: \"The {o} is on the {s}\";\n            on(c, s) :: \"The {c} is on the {s}\"; \n        }\n    }\n}\n\n# push button\ntype b : t {\n    predicates {\n        pushed(b);\n        unpushed(b);\n\n        pair(b, d);\n\n        in(b, c);\n    }\n\n    inform7 {\n        type {\n            kind :: \"button-like\";\n            definition :: \"A button-like can be either pushed or unpushed. A button-like is usually unpushed. A button-like is fixed in place.\";\n        }\n\n        predicates {\n            pushed(b)   :: \"The {b} is pushed\";\n            unpushed(b) :: \"The {b} is unpushed\";\n\n            pair(b, d)  :: \"The {b} pairs to {d}\";\n\n            in(b, c)    :: \"The {b} is in the {c}\";\n        }\n\n        code :: \"\"\"\n            connectivity relates a button-like to a door. The verb to pair to means the connectivity relation. \n\n            Understand the command \"push\" as something new. \n            Understand \"push [something]\" as _pushing. \n            _pushing is an action applying to a thing.  \n\n            Carry out _pushing: \n                if a button-like (called pb) pairs to door (called dr): \n                    if dr is locked:\n                        Now the pb is pushed;                 \n                        Now dr is unlocked; \n                        Now dr is open; \n                    otherwise:\n                        Now the pb is unpushed;                 \n                        Now dr is locked.\n\n            Report _pushing: \n                if a button-like (called pb) pairs to door (called dr): \n                    if dr is unlocked:\n                        say \"You push the [pb], and [dr] is now open.\";\n                    otherwise:\n                        say \"You push the [pb] again, and [dr] is now locked.\"                    \n        \"\"\";\n    }\n}\n\n# container\ntype c : t {\n    predicates {\n        open(c);\n        closed(c);\n        locked(c);\n\n        in(o, c);        \n    }\n\n    rules {\n        # lock/c    :: $at(P, r) & $at(c, r) & $in(k, I) & $match(k, c) & closed(c) & event(c) -> locked(c);\n        # unlock/c  :: $at(P, r) & $at(c, r) & $in(k, I) & $match(k, c) & locked(c) -> closed(c);        \n\n        open/c    :: $at(P, r) & $at(s, r) & $on(c, s) & event(c) & closed(c) -> open(c);\n        close/c   :: $at(P, r) & $at(s, r) & $on(c, s) & open(c) -> closed(c);\n\n        open/c1   :: $at(P, r) & $at(s, r) & $on(c, s) & closed(c) -> open(c);\n        close/c1  :: $at(P, r) & $at(s, r) & $on(c, s) & open(c) -> closed(c);\n    }\n\n    reverse_rules {\n        # lock/c   :: unlock/c;\n        open/c   :: close/c;\n        open/c1  :: close/c1;\n    }\n\n    constraints {\n        c1 :: open(c)   & closed(c) -> fail();\n        c2 :: open(c)   & locked(c) -> fail();\n        c3 :: closed(c) & locked(c) -> fail();\n    }\n\n    inform7 {\n        type {\n            kind :: \"container\";\n            definition :: \"containers are openable, lockable and fixed in place. containers are usually closed.\";\n        }\n\n        predicates {\n            open(c)   :: \"The {c} is open\";\n            closed(c) :: \"The {c} is closed\";\n            locked(c) :: \"The {c} is locked\";\n\n            in(o, c)  :: \"The {o} is in the {c}\";\n        }\n\n        commands {\n            open/c    :: \"open {c}\" :: \"opening the {c}\";\n            close/c   :: \"close {c}\" :: \"closing the {c}\";\n\n            open/c1   :: \"open {c}\" :: \"opening the {c}\";\n            close/c1  :: \"close {c}\" :: \"closing the {c}\";\n\n            # lock/c    :: \"lock {c} with {k}\" :: \"locking the {c} with the {k}\";\n            # unlock/c  :: \"unlock {c} with {k}\" :: \"unlocking the {c} with the {k}\";\n        }\n    }\n}\n\n# key\ntype k : o {\n    predicates {\n        match(k, c);\n        match(k, d);\n    }\n\n    constraints {\n        k1 :: match(k, c) & match(k', c) -> fail();\n        k2 :: match(k, c) & match(k, c') -> fail();\n        k3 :: match(k, d) & match(k', d) -> fail();\n        k4 :: match(k, d) & match(k, d') -> fail();\n    }\n\n    inform7 {\n        type {\n            kind :: \"key\";\n        }\n\n        predicates {\n            match(k, c) :: \"The matching key of the {c} is the {k}\";\n            match(k, d) :: \"The matching key of the {d} is the {k}\";\n        }\n    }\n}\n\n# cloth\ntype l : o {\n    predicates {            \n        worn(l);\n\t    takenoff(l);\n        clean(l);\n\t    dirty(l);\n    \t}\n\n    rules {\n        wear/l    :: in(l, I) & takenoff(l) -> worn(l);\n        takeoff/l :: worn(l) -> in(l, I) & takenoff(l);\n\n        wash/l    :: $at(l,r) & dirty(l) -> clean(l);\n        dirty/l   :: $worn(l,P) & clean(l) -> dirty(l);\n    \t}\n\n    reverse_rules {\n        wear/l :: takeoff/l;\n        wash/l :: dirty/l;\n    \t}\n\n    constraints {\n        l1 :: clean(l) & dirty(l) -> fail();\n        l2 :: worn(l) & takenoff(l) -> fail();\n    \t}\n\n    inform7 {\n        type {\n            kind :: \"cloth-like\";\n            definition :: \"cloth-like are wearable. cloth-like can be either clean or dirty. cloth-like are usually clean. cloth-like can be either worn in or worn out. cloth-like are usually worn out.\";                                          \n        }\n\n        predicates {\n            worn(l)    :: \"The {l} is worn in\";\n\t        takenoff(l) :: \"The {l} is worn out\";            \n            clean(l)    :: \"The {l} is clean\";\n\t        dirty(l)    :: \"The {l} is dirty\";            \n        }\n\n        commands {\n            wear/l :: \"wear {l}\" :: \"_wearing the {l}\";\n            takeoff/l :: \"take off {l}\" :: \"taking off the {l}\";\n\n            clean/l :: \"clean {l}\" :: \"cleaning the {l}\";\n\t        dirty/l :: \"dirty {l}\" :: \"dirtying the {l}\";\n        }\n\n        code :: \"\"\"\n            Understand the command \"wear\" as something new. \n            Understand \"wear [something]\" as _wearing. \n            _wearing is an action applying to a thing.  \n\n            Carry out _wearing: \n                if a cloth-like (called cl) is worn out:                     \n                    Now the cl is worn in;                                                                       \n                otherwise:\n                    Say \"You have this cloth on.\". \n        \"\"\";\n    }\n}\n\n# text-Like\ntype txt : o {\n    predicates {\n        read/t(txt);\n        unread/t(txt);\n    }\n\n    rules {\n        read/book    :: $at(P, r) & $in(txt, I) & unread/t(txt) -> read/t(txt);\n        examine/book :: at(P, r) & $in(txt, I) -> at(P, r);  # Nothing changes.\n    }\n    \n    reverse_rules {\n        examine/book :: examine/book;\n    }\n    \n    constraints {\n        txt1 :: read/t(txt) & unread/t(txt) -> fail();        \n    }\n\n    inform7 {\n        type {\n            kind :: \"text-like\";\n            definition :: \"A text-like can be either read or unread. A text-like is usually unread.\";\n        }\n\n        predicates {\n            read/t(txt)  :: \"The {txt} is read\";\n            unread/t(txt) :: \"The {txt} is unread\";\n        }\n\n        commands {            \n            read/book     :: \"read the {txt}\"    :: \"_reading the {txt}\";\n            examine/book  :: \"examine {txt}\"  :: \"examining the {txt}\";\n        }\n        \n        code :: \"\"\"\n            Understand the command \"read\" as something new. \n            Understand \"read [something]\" as _reading. \n            _reading is an action applying to a thing. \n        \n            Carry out _reading: \n                if a text-like (called tx) is unread: \n                    Say \"You read the book and realized about that crucial hint.\";\n                    Now the tx is read; \n        \"\"\";\n    }\n}\n\n# object\ntype o : t {\n    constraints {\n        obj1 :: in(o, I) & in(o, c) -> fail();\n        obj2 :: in(o, I) & on(o, s) -> fail();\n        obj3 :: in(o, I) & at(o, r) -> fail();\n        obj4 :: in(o, c) & on(o, s) -> fail();\n        obj5 :: in(o, c) & at(o, r) -> fail();\n        obj6 :: on(o, s) & at(o, r) -> fail();\n        obj7 :: at(o, r) & at(o, r') -> fail();\n        obj8 :: in(o, c) & in(o, c') -> fail();\n        obj9 :: on(o, s) & on(o, s') -> fail();\n    }\n\n    inform7 {\n        type {\n            kind :: \"object-like\";\n            definition :: \"object-like is portable.\";\n        }\n    }\n}\n\n# Player\ntype P {\n    rules {\n        look :: at(P, r) -> at(P, r);  # Nothing changes.\n\t    #wear/cloth :: $at(P,r) & at(l,r) -> on(l,P);\n    }\n\n    inform7 {\n        commands {\n            look :: \"look\" :: \"looking\";\n\t        #wear/cloth :: \"wear cloth\" :: \"wearing the cloth\";\n        }\n    }\n}\n\n# thing\ntype t {\n    predicates {\n        event(cpu);\n        event(c);\n        # event(c, cpu);\n    }\n\n    rules {\n        examine/t :: at(P, r) & $at(t, r) -> at(P, r);\n    }\n\n    reverse_rules {\n        examine/t :: examine/t;\n    }\n\n    inform7 { \n        type {\n            kind :: \"thing\";\n        }\n\n        predicates {\n        event(cpu)    :: \"the {cpu} has been read\";\n        event(c)      :: \"the {c} was open\";\n        # event(c, cpu) :: \"the {c} was closed and the {cpu} has been read\";\n        }\n\n        commands {\n            examine/t :: \"examine {t}\" :: \"examining the {t}\";\n        }\n\n        code :: \"\"\"\n            Understand \"tw-set seed [a number]\" as updating the new seed. \n            Updating the new seed is an action applying to a number.\n            Carry out updating the new seed:\n                seed the random-number generator with the number understood.\n        \"\"\";\n    }\n}\n\n", "text_grammars_path": "/home/v-hapurm/Documents/Haki_Git/TextWorld/textworld/challenges/spaceship/textworld_data/text_grammars"}, "metadata": {"desc": "ContentDetection", "mode": "easy", "seeds": {"map": 59225, "objects": 31964, "quest": 43730, "grammar": 657}, "world_size": 1, "uuid": "tw-content_check-Easy"}, "objective": "", "extras": {}}
{"version": 1, "world": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_0", "type": "r"}]}, {"name": "at", "arguments": [{"name": "c_0", "type": "c"}, {"name": "r_1", "type": "r"}]}, {"name": "at", "arguments": [{"name": "l_0", "type": "l"}, {"name": "r_3", "type": "r"}]}, {"name": "at", "arguments": [{"name": "s_0", "type": "s"}, {"name": "r_0", "type": "r"}]}, {"name": "at", "arguments": [{"name": "s_1", "type": "s"}, {"name": "r_2", "type": "r"}]}, {"name": "clean", "arguments": [{"name": "l_0", "type": "l"}]}, {"name": "closed", "arguments": [{"name": "c_0", "type": "c"}]}, {"name": "closed", "arguments": [{"name": "d_0", "type": "d"}]}, {"name": "closed", "arguments": [{"name": "d_1", "type": "d"}]}, {"name": "closed", "arguments": [{"name": "d_2", "type": "d"}]}, {"name": "east_of", "arguments": [{"name": "r_3", "type": "r"}, {"name": "r_2", "type": "r"}]}, {"name": "in", "arguments": [{"name": "b_0", "type": "b"}, {"name": "c_1", "type": "c"}]}, {"name": "in", "arguments": [{"name": "k_0", "type": "k"}, {"name": "c_0", "type": "c"}]}, {"name": "link", "arguments": [{"name": "r_0", "type": "r"}, {"name": "d_0", "type": "d"}, {"name": "r_1", "type": "r"}]}, {"name": "link", "arguments": [{"name": "r_1", "type": "r"}, {"name": "d_0", "type": "d"}, {"name": "r_0", "type": "r"}]}, {"name": "link", "arguments": [{"name": "r_1", "type": "r"}, {"name": "d_1", "type": "d"}, {"name": "r_2", "type": "r"}]}, {"name": "link", "arguments": [{"name": "r_2", "type": "r"}, {"name": "d_1", "type": "d"}, {"name": "r_1", "type": "r"}]}, {"name": "link", "arguments": [{"name": "r_2", "type": "r"}, {"name": "d_2", "type": "d"}, {"name": "r_3", "type": "r"}]}, {"name": "link", "arguments": [{"name": "r_3", "type": "r"}, {"name": "d_2", "type": "d"}, {"name": "r_2", "type": "r"}]}, {"name": "link", "arguments": [{"name": "r_3", "type": "r"}, {"name": "d_3", "type": "d"}, {"name": "r_4", "type": "r"}]}, {"name": "link", "arguments": [{"name": "r_4", "type": "r"}, {"name": "d_3", "type": "d"}, {"name": "r_3", "type": "r"}]}, {"name": "locked", "arguments": [{"name": "c_1", "type": "c"}]}, {"name": "locked", "arguments": [{"name": "d_3", "type": "d"}]}, {"name": "match", "arguments": [{"name": "k_0", "type": "k"}, {"name": "c_1", "type": "c"}]}, {"name": "north_of", "arguments": [{"name": "r_0", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "north_of", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_2", "type": "r"}]}, {"name": "north_of", "arguments": [{"name": "r_3", "type": "r"}, {"name": "r_4", "type": "r"}]}, {"name": "on", "arguments": [{"name": "c_1", "type": "c"}, {"name": "s_1", "type": "s"}]}, {"name": "on", "arguments": [{"name": "cpu_0", "type": "cpu"}, {"name": "s_0", "type": "s"}]}, {"name": "pair", "arguments": [{"name": "b_0", "type": "b"}, {"name": "d_3", "type": "d"}]}, {"name": "south_of", "arguments": [{"name": "r_1", "type": "r"}, {"name": "r_0", "type": "r"}]}, {"name": "south_of", "arguments": [{"name": "r_2", "type": "r"}, {"name": "r_1", "type": "r"}]}, {"name": "south_of", "arguments": [{"name": "r_4", "type": "r"}, {"name": "r_3", "type": "r"}]}, {"name": "takenoff", "arguments": [{"name": "l_0", "type": "l"}]}, {"name": "unpushed", "arguments": [{"name": "b_0", "type": "b"}]}, {"name": "unread/e", "arguments": [{"name": "cpu_0", "type": "cpu"}]}, {"name": "west_of", "arguments": [{"name": "r_2", "type": "r"}, {"name": "r_3", "type": "r"}]}], "grammar": {"theme": "spaceship", "names_to_exclude": [], "include_adj": false, "blend_descriptions": false, "ambiguous_instructions": false, "only_last_action": false, "blend_instructions": false, "allowed_variables_numbering": false, "unique_expansion": false}, "quests": [{"desc": "", "reward": 0, "commands": [], "win_events": [{"commands": [], "actions": [], "condition": {"name": "trigger", "preconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_0", "type": "r"}]}], "postconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_0", "type": "r"}]}, {"name": "event", "arguments": [{"name": "P", "type": "P"}, {"name": "r_0", "type": "r"}]}], "command_template": null, "reverse_name": null, "reverse_command_template": null}}], "fail_events": []}, {"desc": "", "reward": 1, "commands": [], "win_events": [{"commands": [], "actions": [], "condition": {"name": "trigger", "preconditions": [{"name": "open", "arguments": [{"name": "d_0", "type": "d"}]}, {"name": "read/e", "arguments": [{"name": "cpu_0", "type": "cpu"}]}, {"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_1", "type": "r"}]}, {"name": "event", "arguments": [{"name": "P", "type": "P"}, {"name": "r_0", "type": "r"}]}], "postconditions": [{"name": "open", "arguments": [{"name": "d_0", "type": "d"}]}, {"name": "read/e", "arguments": [{"name": "cpu_0", "type": "cpu"}]}, {"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_1", "type": "r"}]}, {"name": "event", "arguments": [{"name": "P", "type": "P"}, {"name": "r_0", "type": "r"}]}, {"name": "event", "arguments": [{"name": "P", "type": "P"}, {"name": "cpu_0", "type": "cpu"}, {"name": "d_0", "type": "d"}, {"name": "r_0", "type": "r"}, {"name": "r_1", "type": "r"}]}], "command_template": null, "reverse_name": null, "reverse_command_template": null}}], "fail_events": [{"commands": [], "actions": [], "condition": {"name": "trigger", "preconditions": [{"name": "unread/e", "arguments": [{"name": "cpu_0", "type": "cpu"}]}, {"name": "open", "arguments": [{"name": "d_0", "type": "d"}]}, {"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_1", "type": "r"}]}, {"name": "event", "arguments": [{"name": "P", "type": "P"}, {"name": "r_0", "type": "r"}]}], "postconditions": [{"name": "unread/e", "arguments": [{"name": "cpu_0", "type": "cpu"}]}, {"name": "open", "arguments": [{"name": "d_0", "type": "d"}]}, {"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_1", "type": "r"}]}, {"name": "event", "arguments": [{"name": "P", "type": "P"}, {"name": "r_0", "type": "r"}]}, {"name": "event", "arguments": [{"name": "P", "type": "P"}, {"name": "cpu_0", "type": "cpu"}, {"name": "d_0", "type": "d"}, {"name": "r_0", "type": "r"}, {"name": "r_1", "type": "r"}]}], "command_template": null, "reverse_name": null, "reverse_command_template": null}}]}, {"desc": "", "reward": 1, "commands": [], "win_events": [{"commands": [], "actions": [], "condition": {"name": "trigger", "preconditions": [{"name": "in", "arguments": [{"name": "k_0", "type": "k"}, {"name": "I", "type": "I"}]}], "postconditions": [{"name": "in", "arguments": [{"name": "k_0", "type": "k"}, {"name": "I", "type": "I"}]}, {"name": "event", "arguments": [{"name": "I", "type": "I"}, {"name": "k_0", "type": "k"}]}], "command_template": null, "reverse_name": null, "reverse_command_template": null}}], "fail_events": []}, {"desc": "", "reward": 1, "commands": [], "win_events": [{"commands": [], "actions": [], "condition": {"name": "trigger", "preconditions": [{"name": "worn", "arguments": [{"name": "l_0", "type": "l"}]}, {"name": "pushed", "arguments": [{"name": "b_0", "type": "b"}]}], "postconditions": [{"name": "worn", "arguments": [{"name": "l_0", "type": "l"}]}, {"name": "pushed", "arguments": [{"name": "b_0", "type": "b"}]}, {"name": "event", "arguments": [{"name": "b_0", "type": "b"}, {"name": "l_0", "type": "l"}]}], "command_template": null, "reverse_name": null, "reverse_command_template": null}}], "fail_events": []}, {"desc": "", "reward": 0, "commands": [], "win_events": [], "fail_events": [{"commands": [], "actions": [], "condition": {"name": "trigger", "preconditions": [{"name": "open", "arguments": [{"name": "d_2", "type": "d"}]}, {"name": "takenoff", "arguments": [{"name": "l_0", "type": "l"}]}, {"name": "pushed", "arguments": [{"name": "b_0", "type": "b"}]}], "postconditions": [{"name": "open", "arguments": [{"name": "d_2", "type": "d"}]}, {"name": "takenoff", "arguments": [{"name": "l_0", "type": "l"}]}, {"name": "pushed", "arguments": [{"name": "b_0", "type": "b"}]}, {"name": "event", "arguments": [{"name": "b_0", "type": "b"}, {"name": "d_2", "type": "d"}, {"name": "l_0", "type": "l"}]}], "command_template": null, "reverse_name": null, "reverse_command_template": null}}]}, {"desc": "", "reward": 1, "commands": [], "win_events": [{"commands": [], "actions": [], "condition": {"name": "trigger", "preconditions": [{"name": "worn", "arguments": [{"name": "l_0", "type": "l"}]}], "postconditions": [{"name": "worn", "arguments": [{"name": "l_0", "type": "l"}]}, {"name": "event", "arguments": [{"name": "l_0", "type": "l"}]}], "command_template": null, "reverse_name": null, "reverse_command_template": null}}], "fail_events": []}, {"desc": "", "reward": 1, "commands": [], "win_events": [{"commands": [], "actions": [], "condition": {"name": "trigger", "preconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_4", "type": "r"}]}], "postconditions": [{"name": "at", "arguments": [{"name": "P", "type": "P"}, {"name": "r_4", "type": "r"}]}, {"name": "event", "arguments": [{"name": "P", "type": "P"}, {"name": "r_4", "type": "r"}]}], "command_template": null, "reverse_name": null, "reverse_command_template": null}}], "fail_events": []}], "infos": [["P", {"id": "P", "type": "P", "name": null, "noun": null, "adj": null, "desc": null, "room_type": "rest", "definite": null, "indefinite": null, "synonyms": null}], ["I", {"id": "I", "type": "I", "name": null, "noun": null, "adj": null, "desc": null, "room_type": null, "definite": null, "indefinite": null, "synonyms": null}], ["r_3", {"id": "r_3", "type": "r", "name": "Hatch", "noun": null, "adj": null, "desc": "This area is like the entrance to the spaceship, so like home entrance with outer and inner doors and a place that outfits are hooked. There are only two important differences: first, if the outer door is open and you don't have outfit on you, you are dead!! No joke here! So make sure that you open the door after wearing those cloths. Second, the door nob to open the door is not neither on the door nor in this room. You should open the external door from Russian Module! woooh so much of safety concerns, yeah?!", "room_type": "rest", "definite": null, "indefinite": null, "synonyms": null}], ["r_2", {"id": "r_2", "type": "r", "name": "Russian Module", "noun": null, "adj": null, "desc": "The Russian module is a typical space lab that you can expect, filled with a lot of processing machines, test equipments and space drive cars, in fact for repair and test. Since it is located at the center of International Space Station, it is also important room for everyone. There are many other objects here and there belongs to other astronauts, probably that's why here looks a bit messy. There are some stuffs here you should pick, obviously if you can find them among all this mess.", "room_type": "rest", "definite": null, "indefinite": null, "synonyms": null}], ["r_0", {"id": "r_0", "type": "r", "name": "Sleep Station", "noun": null, "adj": null, "desc": "This is a typical bedroom in spaceship; here,  it is called sleep station. It is small but comfortable to take a good rest after a day full of missions. However, today your mission will start from here. Wait to be notified by a message. So, you should find that message first. BTW, don't forget that when the Hatch door is open, you should already have worn your specially-designed outfit to be able to enter and stay at Hatch area; otherwise you'll die! Yes! Living in space is tough.", "room_type": "rest", "definite": null, "indefinite": null, "synonyms": null}], ["r_1", {"id": "r_1", "type": "r", "name": "US LAB", "noun": null, "adj": null, "desc": "This is where Americans do their research on Space. In addition to all computers and lab gadgets, you can find a couple of objects here which are useful during your mission. Let's explore the room.", "room_type": "work", "definite": null, "indefinite": null, "synonyms": null}], ["r_4", {"id": "r_4", "type": "r", "name": "Outside", "noun": null, "adj": null, "desc": "Here is outside the spaceship. No Oxygen, no gravity, nothing! If you are here, it means that you have the special outfit on you and you passed the medium level of the game successfully! Congrats!", "room_type": "clean", "definite": null, "indefinite": null, "synonyms": null}], ["d_0", {"id": "d_0", "type": "d", "name": "door A", "noun": null, "adj": null, "desc": "it's a hefty door A [if open]It is open.[else if closed]It is closed.[otherwise]It is locked.[end if]", "room_type": "rest", "definite": null, "indefinite": null, "synonyms": null}], ["d_1", {"id": "d_1", "type": "d", "name": "door B", "noun": null, "adj": null, "desc": "The door B looks well-built. [if open]It is open.[else if closed]It is closed.[otherwise]It is locked.[end if]", "room_type": "rest", "definite": null, "indefinite": null, "synonyms": null}], ["d_2", {"id": "d_2", "type": "d", "name": "door C", "noun": null, "adj": null, "desc": "The door C looks solid. [if open]It is open.[else if closed]It is closed.[otherwise]It is locked.[end if]", "room_type": "rest", "definite": null, "indefinite": null, "synonyms": null}], ["d_3", {"id": "d_3", "type": "d", "name": "door D", "noun": null, "adj": null, "desc": "it's a hefty door D [if open]You can see inside it.[else if closed]You can't see inside it because the lid's in your way.[otherwise]There is a lock on it.[end if]", "room_type": "rest", "definite": null, "indefinite": null, "synonyms": null}], ["c_0", {"id": "c_0", "type": "c", "name": "box A", "noun": null, "adj": null, "desc": "This a regular box, keeps the electronic key to open box B. ", "room_type": "work", "definite": null, "indefinite": null, "synonyms": null}], ["l_0", {"id": "l_0", "type": "l", "name": "outfit", "noun": null, "adj": null, "desc": "", "room_type": "rest", "definite": null, "indefinite": null, "synonyms": null}], ["s_0", {"id": "s_0", "type": "s", "name": "vertical desk", "noun": null, "adj": null, "desc": "This is not a regular table. The surface is installed vertically and your objects are attached or hooked to it, why? Come on! we are in space, there is no gravity here.", "room_type": "rest", "definite": null, "indefinite": null, "synonyms": null}], ["s_1", {"id": "s_1", "type": "s", "name": "metal table", "noun": null, "adj": null, "desc": "This is a big metal table, a messy one, there are many things on it, it is difficult to find what you want. However, there is just one item which is important for you. Try to find that item.", "room_type": "rest", "definite": null, "indefinite": null, "synonyms": null}], ["b_0", {"id": "b_0", "type": "b", "name": "exit push button", "noun": null, "adj": null, "desc": "This push button is a key-like object which opens door C.", "room_type": "rest", "definite": null, "indefinite": null, "synonyms": null}], ["c_1", {"id": "c_1", "type": "c", "name": "box B", "noun": null, "adj": null, "desc": "This box is locked! sounds it carries important item... So, let's find its key to open it. Wait... strange! the lock looks like a keypad!! Wait we've seen something similar to this somewhere before.", "room_type": "rest", "definite": null, "indefinite": null, "synonyms": null}], ["k_0", {"id": "k_0", "type": "k", "name": "electronic key", "noun": null, "adj": null, "desc": "This key is an electronic key which unlocks box B. An electronic key is in fact a code and opens those locks which are equipped with a keypad.", "room_type": "work", "definite": null, "indefinite": null, "synonyms": null}], ["cpu_0", {"id": "cpu_0", "type": "cpu", "name": "laptop", "noun": null, "adj": null, "desc": "This is your personal laptop which is attached to the surface of the table. You can do regular things with this, like check your emails, watch YouTube, Skype with family,etc.Since you are here, we recommend you to check your emails. New missions are posted through emails.", "room_type": "rest", "definite": null, "indefinite": null, "synonyms": null}]], "KB": {"logic": "# room\ntype r {\n    predicates {\n        at(P, r);\n        at(t, r);\n\n        north_of(r, r);\n        west_of(r, r);\n\n        north_of/d(r, d, r);\n        west_of/d(r, d, r);\n\n        free(r, r);\n\n        south_of(r, r') = north_of(r', r);\n        east_of(r, r') = west_of(r', r);\n\n        south_of/d(r, d, r') = north_of/d(r', d, r);\n        east_of/d(r, d, r') = west_of/d(r', d, r);\n    }\n\n    rules {\n        go/north :: at(P, r) & $north_of(r', r) & $free(r, r') & $free(r', r) -> at(P, r');\n        go/south :: at(P, r) & $south_of(r', r) & $free(r, r') & $free(r', r) -> at(P, r');\n        go/east  :: at(P, r) & $east_of(r', r) & $free(r, r') & $free(r', r) -> at(P, r');\n        go/west  :: at(P, r) & $west_of(r', r) & $free(r, r') & $free(r', r) -> at(P, r');\n    }\n\n    reverse_rules {\n        go/north :: go/south;\n        go/west :: go/east;\n    }\n\n    constraints {\n        r1 :: at(P, r) & at(P, r') -> fail();\n        r2 :: at(s, r) & at(s, r') -> fail();\n        r3 :: at(c, r) & at(c, r') -> fail();\n\n        # An exit direction can only lead to one room.\n        nav_rr1 :: north_of(r, r') & north_of(r'', r') -> fail();\n        nav_rr2 :: south_of(r, r') & south_of(r'', r') -> fail();\n        nav_rr3 :: east_of(r, r') & east_of(r'', r') -> fail();\n        nav_rr4 :: west_of(r, r') & west_of(r'', r') -> fail();\n\n        # Two rooms can only be connected once with each other.\n        nav_rrA :: north_of(r, r') & south_of(r, r') -> fail();\n        nav_rrB :: north_of(r, r') & west_of(r, r') -> fail();\n        nav_rrC :: north_of(r, r') & east_of(r, r') -> fail();\n        nav_rrD :: south_of(r, r') & west_of(r, r') -> fail();\n        nav_rrE :: south_of(r, r') & east_of(r, r') -> fail();\n        nav_rrF :: west_of(r, r')  & east_of(r, r') -> fail();\n    }\n\n    inform7 {\n        type {\n            kind :: \"room\";\n        }\n\n        predicates {\n            at(P, r) :: \"The player is in {r}\";\n            at(t, r) :: \"The {t} is in {r}\";\n            free(r, r') :: \"\";  # No equivalent in Inform7.\n\n            north_of(r, r') :: \"The {r} is mapped north of {r'}\";\n            south_of(r, r') :: \"The {r} is mapped south of {r'}\";\n            east_of(r, r') :: \"The {r} is mapped east of {r'}\";\n            west_of(r, r') :: \"The {r} is mapped west of {r'}\";\n\n            north_of/d(r, d, r') :: \"South of {r} and north of {r'} is a door called {d}\";\n            south_of/d(r, d, r') :: \"North of {r} and south of {r'} is a door called {d}\";\n            east_of/d(r, d, r') :: \"West of {r} and east of {r'} is a door called {d}\";\n            west_of/d(r, d, r') :: \"East of {r} and west of {r'} is a door called {d}\";\n        }\n\n        commands {\n            go/north :: \"go north\" :: \"going north\";\n            go/south :: \"go south\" :: \"going south\";\n            go/east :: \"go east\" :: \"going east\";\n            go/west :: \"go west\" :: \"going west\";\n        }\n    }\n}\n\n# CPU-Like\ntype cpu : o {\n    predicates {\n        read/e(cpu);\n        unread/e(cpu);\n    }\n\n    rules {\n        check/e1     :: $at(P, r) & $at(s, r) & $on(cpu, s) & unread/e(cpu) -> read/e(cpu);\n        check/e2     :: $at(P, r) & $in(cpu, I) & unread/e(cpu) -> read/e(cpu);\n    }\n\n    constraints {\n        cpu2 :: read/e(cpu) & unread/e(cpu) -> fail();        \n    }\n\n    inform7 {\n        type {\n            kind :: \"CPU-like\";\n            definition :: \"A CPU-like can be either read or unread. A CPU-like is usually unread.\";\n        }\n\n        predicates {\n            read/e(cpu)     :: \"The {cpu} is read\";\n            unread/e(cpu)   :: \"The {cpu} is unread\";\n        }\n\n        commands {            \n            check/e1     :: \"check laptop for email\"    :: \"checking email\";\n            check/e2     :: \"check laptop for email\"    :: \"checking email\";\n        }\n\n        code :: \"\"\"\n            Understand the command \"check\" as something new. \n            Understand \"check laptop for email\" as checking email. \n            checking email is an action applying to nothing. \n\n            Before checking email:\n                if a CPU-like (called pc) is read:\n                    Say \"You've already read all today's emails.\";\n                    rule fails;\n                otherwise:\n                    if a random chance of 3 in 4 succeeds:\n                        Say \"No emails yet! Wait.\";\n                        rule fails.\n\n            Carry out checking email: \n                if a CPU-like (called pc) is unread: \n                    Say \"Email: Your mission is started. You should go and check outside of the spaceship.\";\n                    Now the pc is read.\n        \"\"\";\n    }\n}\n\n# door\ntype d : t {\n    predicates {\n        open(d);\n        closed(d);\n        locked(d);\n\n        link(r, d, r);\n    }\n\n    rules {\n        lock/d          :: $at(P, r) & $link(r, d, r') & $link(r', d, r) & $in(k, I) & $match(k, d) & closed(d) -> locked(d);\n        unlock/d        :: $at(P, r) & $link(r, d, r') & $link(r', d, r) & $in(k, I) & $match(k, d) & locked(d) -> closed(d);\n\n        open/d          :: $at(P, r) & $link(r, d, r') & $link(r', d, r) & closed(d) -> open(d) & free(r, r') & free(r', r);\n        close/d         :: $at(P, r) & $link(r, d, r') & $link(r', d, r) & open(d) & free(r, r') & free(r', r) -> closed(d);\n        \n        lock/close/db   :: $at(P, r) & $at(s, r) & $on(c, s) & $open(c) & $in(b, c) & $pair(b, d) & pushed(b) & open(d) & free(r, r') & free(r', r) -> unpushed(b) & locked(d);\n        unlock/open/db  :: $at(P, r) & $at(s, r) & $on(c, s) & $open(c) & $in(b, c) & $pair(b, d) & unpushed(b) & locked(d) -> pushed(b) & open(d) & free(r, r') & free(r', r);\n\n        lock/close/d/b  :: $at(P, r) & $at(s, r) & $on(c, s) & $open(c) & $in(b, c) & $pair(b, d) & $link(r', d, r'') & $link(r'', d, r') & pushed(b) & open(d) & free(r', r'') & free(r'', r') -> unpushed(b) & locked(d);\n        unlock/open/d/b :: $at(P, r) & $at(s, r) & $on(c, s) & $open(c) & $in(b, c) & $pair(b, d) & $link(r', d, r'') & $link(r'', d, r') & unpushed(b) & locked(d) -> pushed(b) & open(d) & free(r', r'') & free(r'', r');\n\n        examine/d       :: at(P, r) & $link(r, d, r') -> at(P, r);  # Nothing changes.\n    }\n\n    reverse_rules {\n        lock/d :: unlock/d;\n        open/d :: close/d;\n        lock/close/d/b :: unlock/open/d/b;\n        lock/close/db :: unlock/open/db;\n    }\n\n    constraints {\n        d1 :: open(d)   & closed(d) -> fail();\n        d2 :: open(d)   & locked(d) -> fail();\n        d3 :: closed(d) & locked(d) -> fail();\n\n        # A door can't be used to link more than two rooms.\n        link1          :: link(r, d, r') & link(r, d, r'') -> fail();\n        link2          :: link(r, d, r') & link(r'', d, r''') -> fail();\n\n        # There's already a door linking two rooms.\n        link3          :: link(r, d, r') & link(r, d', r') -> fail();\n\n        # There cannot be more than four doors in a room.\n        too_many_doors :: link(r, d1: d, r1: r) & link(r, d2: d, r2: r) & link(r, d3: d, r3: r) & link(r, d4: d, r4: r) & link(r, d5: d, r5: r) -> fail();\n\n        # There cannot be more than four doors in a room.\n        dr1   :: free(r, r1: r) & link(r, d2: d, r2: r) & link(r, d3: d, r3: r) & link(r, d4: d, r4: r) & link(r, d5: d, r5: r) -> fail();\n        dr2   :: free(r, r1: r) & free(r, r2: r) & link(r, d3: d, r3: r) & link(r, d4: d, r4: r) & link(r, d5: d, r5: r) -> fail();\n        dr3   :: free(r, r1: r) & free(r, r2: r) & free(r, r3: r) & link(r, d4: d, r4: r) & link(r, d5: d, r5: r) -> fail();\n        dr4   :: free(r, r1: r) & free(r, r2: r) & free(r, r3: r) & free(r, r4: r) & link(r, d5: d, r5: r) -> fail();\n\n        free1 :: link(r, d, r') & free(r, r') & closed(d) -> fail();\n        free2 :: link(r, d, r') & free(r, r') & locked(d) -> fail();\n    }\n\n    inform7 {\n        type {\n            kind       :: \"door\";\n            definition :: \"door is openable and lockable.\";\n        }\n\n        predicates {\n            open(d)         :: \"The {d} is open\";\n            closed(d)       :: \"The {d} is closed\";\n            locked(d)       :: \"The {d} is locked\";\n            \n            link(r, d, r')  :: \"\";  # No equivalent in Inform7.\n        }\n\n        commands {\n            open/d          :: \"open {d}\"            :: \"opening {d}\";\n            close/d         :: \"close {d}\"           :: \"closing {d}\";\n\n            unlock/d        :: \"unlock {d} with {k}\" :: \"unlocking {d} with the {k}\";\n            lock/d          :: \"lock {d} with {k}\"   :: \"locking {d} with the {k}\";\n\n            lock/close/d/b  :: \"push {b}\"            :: \"_pushing the {b}\";\n            unlock/open/d/b :: \"push {b}\"            :: \"_pushing the {b}\";\n\n            lock/close/db   :: \"push {b}\"            :: \"_pushing the {b}\";\n            unlock/open/db  :: \"push {b}\"            :: \"_pushing the {b}\";\n\n            examine/d       :: \"examine {d}\"         :: \"examining the {d}\";\n        }\n    }\n}\n\n# Inventory\ntype I {\n    predicates {\n        in(o, I);\n    }\n\n    rules {\n        inventory  :: at(P, r) -> at(P, r);  # Nothing changes.\n\n        take       :: $at(P, r) & at(o, r) -> in(o, I);\n        \n        take/c     :: $at(P, r) & $at(c, r) & $open(c) & in(o, c) -> in(o, I);\n        insert/c   :: $at(P, r) & $at(c, r) & $open(c) & in(o, I) -> in(o, c);\n\n        take/cs    :: $at(P, r) & $at(s, r) & $on(c, s) & $open(c) & in(o, c) -> in(o, I);\n        insert/cs  :: $at(P, r) & $at(s, r) & $on(c, s) & $open(c) & in(o, I) -> in(o, c);\n\n        take/s     :: $at(P, r) & $at(s, r) & on(o, s) -> in(o, I);\n        hook       :: $at(P, r) & $at(s, r) & in(o, I) -> on(o, s);\n\n        examine/I  :: in(o, I) -> in(o, I);  # Nothing changes.\n        examine/s  :: at(P, r) & $at(s, r) & $on(o, s) -> at(P, r);  # Nothing changes.\n        examine/c  :: at(P, r) & $at(c, r) & $open(c) & $in(o, c) -> at(P, r);  # Nothing changes.\n        examine/or :: at(P, r) & $in(o, r) -> at(P, r);  # Nothing changes.\n        examine/oc :: at(P, r) & $at(c, r) & $open(c) & $in(o, c) -> at(P, r);  # Nothing changes.\n        examine/os :: at(P, r) & $at(s, r) & $on(o, s) -> at(P, r);  # Nothing changes.\n    }\n\n    reverse_rules {    \n        inventory  :: inventory;\n\n        take/c     :: insert/c;\n        take/s     :: hook;\n        take/cs    :: insert/cs;\n\n        examine/I  :: examine/I;\n        examine/s  :: examine/s;\n        examine/c  :: examine/c;\n        examine/or :: examine/or;\n        examine/oc :: examine/oc;\n        examine/os :: examine/os;\n    }\n\n    inform7 {\n        predicates {\n            in(o, I) :: \"The player carries the {o}\";\n        }\n\n        commands {\n\n            inventory  :: \"inventory\" :: \"taking inventory\";\n\n            take       :: \"take {o}\" :: \"taking the {o}\";                \n\n            take/c     :: \"take {o} from {c}\" :: \"removing the {o} from the {c}\";\n            insert/c   :: \"insert {o} into {c}\" :: \"inserting the {o} into the {c}\";\n\n            take/cs    :: \"take {o} from {c}\" :: \"removing the {o} from the {c}\";\n            insert/cs  :: \"insert {o} into {c}\" :: \"inserting the {o} into the {c}\";\n\n            take/s     :: \"take {o} from {s}\" :: \"removing the {o} from the {s}\";\n            hook       :: \"hook {o} on {s}\" :: \"hooking the {o} on the {s}\";\n\n            examine/I  :: \"examine {o}\" :: \"examining the {o}\";\n            examine/s  :: \"examine {o}\" :: \"examining the {o}\";\n            examine/c  :: \"examine {o}\" :: \"examining the {o}\";\n            examine/or :: \"examine {o}\" :: \"examining the {o}\";\n            examine/oc :: \"examine {o}\" :: \"examining the {o}\";\n            examine/os :: \"examine {o}\" :: \"examining the {o}\";\n        }\n    }\n}\n\n# food\ntype f : o {\n    predicates {\n        edible(f);\n        eaten(f);\n    }\n\n    rules {\n        eat :: in(f, I) -> eaten(f);\n    }\n\n    constraints {\n        eaten1 :: eaten(f) & in(f, I) -> fail();\n        eaten2 :: eaten(f) & in(f, c) -> fail();\n        eaten3 :: eaten(f) & on(f, s) -> fail();\n        eaten4 :: eaten(f) & at(f, r) -> fail();\n    }\n\n    inform7 {\n        type {\n            kind :: \"food\";\n            definition :: \"food is edible.\";\n        }\n\n        predicates {\n            edible(f) :: \"The {f} is edible\";\n            eaten(f) :: \"The {f} is nowhere\";\n        }\n\n        commands {\n            eat :: \"eat {f}\" :: \"eating the {f}\";\n        }\n    }\n}\n\n# supporter\ntype s : t {\n    predicates {\n        on(o, s);\n        on(c, s);\n    }\n\n    inform7 {\n        type {\n            kind :: \"supporter\";\n            definition :: \"supporters are fixed in place.\";\n        }\n\n        predicates {\n            on(o, s) :: \"The {o} is on the {s}\";\n            on(c, s) :: \"The {c} is on the {s}\"; \n        }\n    }\n}\n\n# push button\ntype b : t {\n    predicates {\n        pushed(b);\n        unpushed(b);\n\n        pair(b, d);\n\n        in(b, c);\n    }\n\n    inform7 {\n        type {\n            kind :: \"button-like\";\n            definition :: \"A button-like can be either pushed or unpushed. A button-like is usually unpushed. A button-like is fixed in place.\";\n        }\n\n        predicates {\n            pushed(b)   :: \"The {b} is pushed\";\n            unpushed(b) :: \"The {b} is unpushed\";\n\n            pair(b, d)  :: \"The {b} pairs to {d}\";\n\n            in(b, c)    :: \"The {b} is in the {c}\";\n        }\n\n        code :: \"\"\"\n            connectivity relates a button-like to a door. The verb to pair to means the connectivity relation. \n\n            Understand the command \"push\" as something new. \n            Understand \"push [something]\" as _pushing. \n            _pushing is an action applying to a thing.  \n\n            Carry out _pushing: \n                if a button-like (called pb) pairs to door (called dr): \n                    if dr is locked:\n                        Now the pb is pushed;                 \n                        Now dr is unlocked; \n                        Now dr is open; \n                    otherwise:\n                        Now the pb is unpushed;                 \n                        Now dr is locked.\n\n            Report _pushing: \n                if a button-like (called pb) pairs to door (called dr): \n                    if dr is unlocked:\n                        say \"You push the [pb], and [dr] is now open.\";\n                    otherwise:\n                        say \"You push the [pb] again, and [dr] is now locked.\"                    \n        \"\"\";\n    }\n}\n\n# container\ntype c : t {\n    predicates {\n        open(c);\n        closed(c);\n        locked(c);\n\n        in(o, c);        \n    }\n\n    rules {\n        lock/c    :: $at(P, r) & $at(c, r) & $in(k, I) & $match(k, c) & closed(c) -> locked(c);\n        unlock/c  :: $at(P, r) & $at(c, r) & $in(k, I) & $match(k, c) & locked(c) -> closed(c);\n\n        open/c    :: $at(P, r) & $at(c, r) & closed(c) -> open(c);        \n        close/c   :: $at(P, r) & $at(c, r) & open(c)   -> closed(c);\n\n        lock/bx   :: $at(P, r) & $at(s, r) & $on(c, s) & $in(k, I) & $match(k, c) & closed(c) -> locked(c);\n        unlock/bx :: $at(P, r) & $at(s, r) & $on(c, s) & $in(k, I) & $match(k, c) & locked(c) -> closed(c);\n\n        open/bx   :: $at(P, r) & $at(s, r) & $on(c, s) & closed(c) -> open(c);\n        close/bx  :: $at(P, r) & $at(s, r) & $on(c, s) & open(c)   -> closed(c);\n    }\n\n    reverse_rules {\n        lock/c  :: unlock/c;\n        open/c  :: close/c;\n        lock/bx :: unlock/bx;\n        open/bx :: close/bx;\n    }\n\n    constraints {\n        c1 :: open(c)   & closed(c) -> fail();\n        c2 :: open(c)   & locked(c) -> fail();\n        c3 :: closed(c) & locked(c) -> fail();\n    }\n\n    inform7 {\n        type {\n            kind :: \"container\";\n            definition :: \"containers are openable, lockable and fixed in place. containers are usually closed.\";\n        }\n\n        predicates {\n            open(c) :: \"The {c} is open\";\n            closed(c) :: \"The {c} is closed\";\n            locked(c) :: \"The {c} is locked\";\n\n            in(o, c) :: \"The {o} is in the {c}\";\n        }\n\n        commands {\n            open/c    :: \"open {c}\" :: \"opening the {c}\";\n            close/c   :: \"close {c}\" :: \"closing the {c}\";\n\n            lock/c    :: \"lock {c} with {k}\" :: \"locking the {c} with the {k}\";\n            unlock/c  :: \"unlock {c} with {k}\" :: \"unlocking the {c} with the {k}\";\n\n            open/bx   :: \"open {c}\" :: \"opening the {c}\";\n            close/bx  :: \"close {c}\" :: \"closing the {c}\";\n\n            lock/bx   :: \"lock {c} with {k}\" :: \"locking the {c} with the {k}\";\n            unlock/bx :: \"unlock {c} with {k}\" :: \"unlocking the {c} with the {k}\";\n        }\n    }\n}\n\n# key\ntype k : o {\n    predicates {\n        match(k, c);\n        match(k, d);\n    }\n\n    constraints {\n        k1 :: match(k, c) & match(k', c) -> fail();\n        k2 :: match(k, c) & match(k, c') -> fail();\n        k3 :: match(k, d) & match(k', d) -> fail();\n        k4 :: match(k, d) & match(k, d') -> fail();\n    }\n\n    inform7 {\n        type {\n            kind :: \"key\";\n        }\n\n        predicates {\n            match(k, c) :: \"The matching key of the {c} is the {k}\";\n            match(k, d) :: \"The matching key of the {d} is the {k}\";\n        }\n    }\n}\n\n# cloth\ntype l : o {\n    predicates {            \n        worn(l);\n\t    takenoff(l);\n        clean(l);\n\t    dirty(l);\n    \t}\n\n    rules {\n        wear/l    :: in(l, I) & takenoff(l) -> worn(l);\n        takeoff/l :: worn(l) -> in(l, I) & takenoff(l);\n\n        wash/l    :: $at(l,r) & dirty(l) -> clean(l);\n        dirty/l   :: $worn(l,P) & clean(l) -> dirty(l);\n    \t}\n\n    reverse_rules {\n        wear/l :: takeoff/l;\n        wash/l :: dirty/l;\n    \t}\n\n    constraints {\n        l1 :: clean(l) & dirty(l) -> fail();\n        l2 :: worn(l) & takenoff(l) -> fail();\n    \t}\n\n    inform7 {\n        type {\n            kind :: \"cloth-like\";\n            definition :: \"cloth-like are wearable. cloth-like can be either clean or dirty. cloth-like are usually clean. cloth-like can be either worn in or worn out. cloth-like are usually worn out.\";                                          \n        }\n\n        predicates {\n            worn(l)    :: \"The {l} is worn in\";\n\t        takenoff(l) :: \"The {l} is worn out\";            \n            clean(l)    :: \"The {l} is clean\";\n\t        dirty(l)    :: \"The {l} is dirty\";            \n        }\n\n        commands {\n            wear/l :: \"wear {l}\" :: \"_wearing the {l}\";\n            takeoff/l :: \"take off {l}\" :: \"taking off the {l}\";\n\n            clean/l :: \"clean {l}\" :: \"cleaning the {l}\";\n\t        dirty/l :: \"dirty {l}\" :: \"dirtying the {l}\";\n        }\n\n        code :: \"\"\"\n            Understand the command \"wear\" as something new. \n            Understand \"wear [something]\" as _wearing. \n            _wearing is an action applying to a thing.  \n\n            Carry out _wearing: \n                if a cloth-like (called cl) is worn out:                     \n                    Now the cl is worn in;                                                                       \n                otherwise:\n                    Say \"You have this cloth on.\". \n        \"\"\";\n    }\n}\n\n# text-Like\ntype txt : o {\n    predicates {\n        read/t(txt);\n        unread/t(txt);\n    }\n\n    rules {\n        read/book    :: $at(P, r) & $in(txt, I) & unread/t(txt) -> read/t(txt);\n        examine/book :: at(P, r) & $in(txt, I) -> at(P, r);  # Nothing changes.\n    }\n    \n    reverse_rules {\n        examine/book :: examine/book;\n    }\n    \n    constraints {\n        txt1 :: read/t(txt) & unread/t(txt) -> fail();        \n    }\n\n    inform7 {\n        type {\n            kind :: \"text-like\";\n            definition :: \"A text-like can be either read or unread. A text-like is usually unread.\";\n        }\n\n        predicates {\n            read/t(txt)  :: \"The {txt} is read\";\n            unread/t(txt) :: \"The {txt} is unread\";\n        }\n\n        commands {            \n            read/book     :: \"read the {txt}\"    :: \"_reading the {txt}\";\n            examine/book  :: \"examine {txt}\"  :: \"examining the {txt}\";\n        }\n        \n        code :: \"\"\"\n            Understand the command \"read\" as something new. \n            Understand \"read [something]\" as _reading. \n            _reading is an action applying to a thing. \n        \n            Carry out _reading: \n                if a text-like (called tx) is unread: \n                    Say \"You read the book and realized about that crucial hint.\";\n                    Now the tx is read; \n        \"\"\";\n    }\n}\n\n# object\ntype o : t {\n    constraints {\n        obj1 :: in(o, I) & in(o, c) -> fail();\n        obj2 :: in(o, I) & on(o, s) -> fail();\n        obj3 :: in(o, I) & at(o, r) -> fail();\n        obj4 :: in(o, c) & on(o, s) -> fail();\n        obj5 :: in(o, c) & at(o, r) -> fail();\n        obj6 :: on(o, s) & at(o, r) -> fail();\n        obj7 :: at(o, r) & at(o, r') -> fail();\n        obj8 :: in(o, c) & in(o, c') -> fail();\n        obj9 :: on(o, s) & on(o, s') -> fail();\n    }\n\n    inform7 {\n        type {\n            kind :: \"object-like\";\n            definition :: \"object-like is portable.\";\n        }\n    }\n}\n\n# Player\ntype P {\n    rules {\n        look :: at(P, r) -> at(P, r);  # Nothing changes.\n\t    #wear/cloth :: $at(P,r) & at(l,r) -> on(l,P);\n    }\n\n    inform7 {\n        commands {\n            look :: \"look\" :: \"looking\";\n\t        #wear/cloth :: \"wear cloth\" :: \"wearing the cloth\";\n        }\n    }\n}\n\n# thing\ntype t {\n    predicates {\n        event(P, r);\n    }\n\n    rules {\n        examine/t :: at(P, r) & $at(t, r) -> at(P, r);\n    }\n\n    reverse_rules {\n        examine/t :: examine/t;\n    }\n\n    inform7 { \n        type {\n            kind :: \"thing\";\n        }\n\n        predicates {\n        event(P, r) :: \"the player was in {r}\";\n        }\n        commands {\n            examine/t :: \"examine {t}\" :: \"examining the {t}\";\n        }\n\n        code :: \"\"\"\n            Understand \"tw-set seed [a number]\" as updating the new seed. \n            Updating the new seed is an action applying to a number.\n            Carry out updating the new seed:\n                seed the random-number generator with the number understood.\n        \"\"\";\n    }\n}\n\n", "text_grammars_path": "/home/v-hapurm/Documents/Haki_Git/TextWorld/textworld/challenges/spaceship/textworld_data/text_grammars"}, "metadata": {"desc": "Spaceship", "mode": "medium", "seeds": {"map": 59225, "objects": 31964, "quest": 43730, "grammar": 657}, "world_size": 8, "uuid": "tw-spaceship-Medium"}, "objective": ""}